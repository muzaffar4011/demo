"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[9776],{4870(n,e,i){i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>t,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"module-2/collisions","title":"Collisions","description":"Collision detection is a critical component of physics simulation for humanoid robots, ensuring realistic interactions with the environment and preventing parts of the robot from passing through obstacles or itself.","source":"@site/docs/module-2/collisions.md","sourceDirName":"module-2","slug":"/module-2/collisions","permalink":"/physical-ai-humanoid-robotics/docs/module-2/collisions","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/physical-ai-humanoid-robotics/edit/main/docusaurus/docs/module-2/collisions.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Collisions"},"sidebar":"tutorialSidebar","previous":{"title":"Physics Simulation","permalink":"/physical-ai-humanoid-robotics/docs/module-2/physics-simulation"},"next":{"title":"Rendering","permalink":"/physical-ai-humanoid-robotics/docs/module-2/rendering"}}');var l=i(4848),s=i(8453);const t={sidebar_position:3,title:"Collisions"},r="Collision Detection and Handling",c={},a=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Collision Detection",id:"introduction-to-collision-detection",level:2},{value:"Collision Geometries",id:"collision-geometries",level:2},{value:"Simple Geometries",id:"simple-geometries",level:3},{value:"Mesh Collisions",id:"mesh-collisions",level:3},{value:"Self-Collision Avoidance",id:"self-collision-avoidance",level:2},{value:"Collision Parameters and Optimization",id:"collision-parameters-and-optimization",level:2},{value:"Contact Parameters",id:"contact-parameters",level:3},{value:"Collision Detection Settings",id:"collision-detection-settings",level:3},{value:"Collision Filtering",id:"collision-filtering",level:2},{value:"Environment Collision Detection",id:"environment-collision-detection",level:2},{value:"Ground Plane",id:"ground-plane",level:3},{value:"Obstacle Detection",id:"obstacle-detection",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Collision Simplification",id:"collision-simplification",level:3},{value:"Simulation Parameters",id:"simulation-parameters",level:3},{value:"Common Collision Issues in Humanoid Simulation",id:"common-collision-issues-in-humanoid-simulation",level:2},{value:"Penetration",id:"penetration",level:3},{value:"Jittering",id:"jittering",level:3},{value:"Self-Collision Conflicts",id:"self-collision-conflicts",level:3},{value:"Advanced Collision Techniques",id:"advanced-collision-techniques",level:2},{value:"Custom Contact Sensors",id:"custom-contact-sensors",level:3},{value:"Dynamic Collision Environments",id:"dynamic-collision-environments",level:3},{value:"Exercise",id:"exercise",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.header,{children:(0,l.jsx)(e.h1,{id:"collision-detection-and-handling",children:"Collision Detection and Handling"})}),"\n",(0,l.jsx)(e.p,{children:"Collision detection is a critical component of physics simulation for humanoid robots, ensuring realistic interactions with the environment and preventing parts of the robot from passing through obstacles or itself."}),"\n",(0,l.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,l.jsx)(e.p,{children:"After completing this lesson, you will be able to:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Implement accurate collision geometries for humanoid robot models"}),"\n",(0,l.jsx)(e.li,{children:"Configure collision detection parameters for optimal performance"}),"\n",(0,l.jsx)(e.li,{children:"Handle self-collision and environment collision scenarios"}),"\n",(0,l.jsx)(e.li,{children:"Optimize collision detection for real-time humanoid robot simulation"}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"introduction-to-collision-detection",children:"Introduction to Collision Detection"}),"\n",(0,l.jsx)(e.p,{children:"Collision detection in robotic simulation involves:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Broad phase"}),": Quick elimination of non-colliding pairs"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Narrow phase"}),": Precise collision detection for potentially colliding pairs"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Contact generation"}),": Determining contact points, normals, and penetration depth"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"For humanoid robots, collision detection is particularly challenging due to:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Complex articulated structures with many potential collision pairs"}),"\n",(0,l.jsx)(e.li,{children:"Close proximity of limbs during natural movements"}),"\n",(0,l.jsx)(e.li,{children:"Need for accurate contact points for balance and manipulation"}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"collision-geometries",children:"Collision Geometries"}),"\n",(0,l.jsx)(e.h3,{id:"simple-geometries",children:"Simple Geometries"}),"\n",(0,l.jsx)(e.p,{children:"For performance, simple geometries are preferred:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Box collision for torso --\x3e\n<collision name="torso_collision">\n  <geometry>\n    <box>\n      <size>0.2 0.15 0.4</size>\n    </box>\n  </geometry>\n</collision>\n\n\x3c!-- Cylinder collision for limbs --\x3e\n<collision name="upper_arm_collision">\n  <geometry>\n    <cylinder>\n      <length>0.3</length>\n      <radius>0.06</radius>\n    </cylinder>\n  </geometry>\n</collision>\n\n\x3c!-- Sphere collision for simplified elements --\x3e\n<collision name="head_collision">\n  <geometry>\n    <sphere>\n      <radius>0.1</radius>\n    </sphere>\n  </geometry>\n</collision>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"mesh-collisions",children:"Mesh Collisions"}),"\n",(0,l.jsx)(e.p,{children:"For high accuracy, mesh collisions can be used, but they are computationally expensive:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<collision name="detailed_hand_collision">\n  <geometry>\n    <mesh>\n      <uri>model://humanoid/meshes/hand_collision.dae</uri>\n    </mesh>\n  </geometry>\n</collision>\n'})}),"\n",(0,l.jsx)(e.h2,{id:"self-collision-avoidance",children:"Self-Collision Avoidance"}),"\n",(0,l.jsx)(e.p,{children:"Humanoid robots must avoid self-collision during movement:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<link name="left_upper_arm">\n  <collision name="upper_arm_collision">\n    <geometry>\n      <cylinder>\n        <length>0.3</length>\n        <radius>0.05</radius>\n      </cylinder>\n    </geometry>\n    \x3c!-- Disable self-collision with adjacent links --\x3e\n    <self_collide>false</self_collide>\n  </collision>\n</link>\n\n\x3c!-- For complex self-collision scenarios --\x3e\n<joint name="shoulder" type="revolute">\n  <physics>\n    <ode>\n      <provide_feedback>true</provide_feedback>\n    </ode>\n  </physics>\n</joint>\n'})}),"\n",(0,l.jsx)(e.h2,{id:"collision-parameters-and-optimization",children:"Collision Parameters and Optimization"}),"\n",(0,l.jsx)(e.h3,{id:"contact-parameters",children:"Contact Parameters"}),"\n",(0,l.jsx)(e.p,{children:"Fine-tune contact behavior for realistic interactions:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<collision name="foot_collision">\n  <geometry>\n    <box>\n      <size>0.15 0.1 0.05</size>\n    </box>\n  </geometry>\n  <surface>\n    <contact>\n      <ode>\n        <soft_cfm>0</soft_cfm>\n        <soft_erp>0.2</soft_erp>\n        <kp>1000000000000.0</kp>\n        <kd>1000000000000.0</kd>\n        <max_vel>100.0</max_vel>\n        <min_depth>0.001</min_depth>\n      </ode>\n    </contact>\n    <friction>\n      <ode>\n        <mu>1.0</mu>\n        <mu2>1.0</mu2>\n      </ode>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"collision-detection-settings",children:"Collision Detection Settings"}),"\n",(0,l.jsx)(e.p,{children:"Configure global collision detection parameters:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<world name="humanoid_world">\n  <physics type="ode">\n    \x3c!-- Collision detection parameters --\x3e\n    <max_step_size>0.001</max_step_size>\n    <real_time_factor>1.0</real_time_factor>\n\n    \x3c!-- Contact parameters --\x3e\n    <ode>\n      <solver>\n        <type>quick</type>\n        <iters>1000</iters>\n        <sor>1.3</sor>\n      </solver>\n      <constraints>\n        <cfm>0.000001</cfm>\n        <erp>0.2</erp>\n        <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n        <contact_surface_layer>0.001</contact_surface_layer>\n      </constraints>\n    </ode>\n  </physics>\n</world>\n'})}),"\n",(0,l.jsx)(e.h2,{id:"collision-filtering",children:"Collision Filtering"}),"\n",(0,l.jsx)(e.p,{children:"Prevent unnecessary collision checks between specific links:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'\x3c!-- In URDF/Xacro, use collision groups --\x3e\n<gazebo reference="left_upper_arm">\n  <collision>\n    <surface>\n      <contact>\n        <collide_without_contact>0</collide_without_contact>\n      </contact>\n    </surface>\n  </collision>\n</gazebo>\n'})}),"\n",(0,l.jsx)(e.h2,{id:"environment-collision-detection",children:"Environment Collision Detection"}),"\n",(0,l.jsx)(e.h3,{id:"ground-plane",children:"Ground Plane"}),"\n",(0,l.jsx)(e.p,{children:"Proper ground collision is essential for humanoid locomotion:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<model name="ground_plane">\n  <static>true</static>\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <plane>\n          <normal>0 0 1</normal>\n        </plane>\n      </geometry>\n      <surface>\n        <friction>\n          <ode>\n            <mu>1.0</mu>\n            <mu2>1.0</mu2>\n          </ode>\n        </friction>\n      </surface>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <plane>\n          <normal>0 0 1</normal>\n          <size>100 100</size>\n        </plane>\n      </geometry>\n    </visual>\n  </link>\n</model>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"obstacle-detection",children:"Obstacle Detection"}),"\n",(0,l.jsx)(e.p,{children:"Configure collision properties for environmental objects:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<model name="obstacle_box">\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>0.5 0.5 0.5</size>\n        </box>\n      </geometry>\n      <surface>\n        <friction>\n          <ode>\n            <mu>0.5</mu>\n            <mu2>0.5</mu2>\n          </ode>\n        </friction>\n        <bounce>\n          <restitution_coefficient>0.1</restitution_coefficient>\n          <threshold>100000</threshold>\n        </bounce>\n      </surface>\n    </collision>\n  </link>\n</model>\n'})}),"\n",(0,l.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,l.jsx)(e.h3,{id:"collision-simplification",children:"Collision Simplification"}),"\n",(0,l.jsx)(e.p,{children:"Balance accuracy with performance:"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Use simple geometries"})," where possible (boxes, cylinders, spheres)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Adjust collision mesh resolution"})," for complex shapes"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Disable collision"})," for links that don't need it during certain operations"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Use bounding volume hierarchies"})," for complex models"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"simulation-parameters",children:"Simulation Parameters"}),"\n",(0,l.jsx)(e.p,{children:"Tune for humanoid robot simulation:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Time step"}),": 0.001s for accurate collision detection"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Solver iterations"}),": Higher for stable contact (50-200)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Contact surface layer"}),": Prevents jitter (0.001-0.01)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Max correcting velocity"}),": Limits contact response (1-100)"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"common-collision-issues-in-humanoid-simulation",children:"Common Collision Issues in Humanoid Simulation"}),"\n",(0,l.jsx)(e.h3,{id:"penetration",children:"Penetration"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Cause"}),": Large time steps or insufficient solver iterations"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Solution"}),": Reduce time step, increase solver iterations"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"jittering",children:"Jittering"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Cause"}),": Inadequate contact stabilization"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Solution"}),": Adjust ERP (Error Reduction Parameter) and CFM (Constraint Force Mixing)"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"self-collision-conflicts",children:"Self-Collision Conflicts"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Cause"}),": Aggressive joint movements"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Solution"}),": Implement joint limits and collision filters"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"advanced-collision-techniques",children:"Advanced Collision Techniques"}),"\n",(0,l.jsx)(e.h3,{id:"custom-contact-sensors",children:"Custom Contact Sensors"}),"\n",(0,l.jsx)(e.p,{children:"Implement custom collision detection for specific applications:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<sensor name="contact_sensor" type="contact">\n  <always_on>1</always_on>\n  <update_rate>30</update_rate>\n  <contact>\n    <collision>foot_collision</collision>\n  </contact>\n  <plugin name="contact_plugin" filename="libContactPlugin.so">\n    <topic>contact_info</topic>\n  </plugin>\n</sensor>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"dynamic-collision-environments",children:"Dynamic Collision Environments"}),"\n",(0,l.jsx)(e.p,{children:"For complex scenarios:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<model name="movable_object">\n  <link name="link">\n    \x3c!-- Physics properties for dynamic objects --\x3e\n    <inertial>\n      <mass>1.0</mass>\n      <inertia>\n        <ixx>0.1</ixx>\n        <ixy>0</ixy>\n        <ixz>0</ixz>\n        <iyy>0.1</iyy>\n        <iyz>0</iyz>\n        <izz>0.1</izz>\n      </inertia>\n    </inertial>\n  </link>\n</model>\n'})}),"\n",(0,l.jsx)(e.h2,{id:"exercise",children:"Exercise"}),"\n",(0,l.jsx)(e.p,{children:"Create a humanoid robot model with appropriate collision geometries for all links. Test the model in Gazebo with various obstacles to ensure proper collision detection and response."}),"\n",(0,l.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,l.jsx)(e.p,{children:"Collision detection is essential for realistic humanoid robot simulation. Proper configuration of collision geometries, parameters, and optimization techniques ensures accurate and efficient simulation. In the next lesson, we'll explore rendering and visualization aspects of digital twins."})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>t,x:()=>r});var o=i(6540);const l={},s=o.createContext(l);function t(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:t(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);