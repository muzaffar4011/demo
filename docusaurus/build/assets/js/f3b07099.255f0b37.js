"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[4911],{6209(e,n,s){s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"module-1/topics-services","title":"Topics and Services","description":"ROS 2 provides two primary communication patterns: topics (for asynchronous, broadcast communication) and services (for synchronous, request-response communication). Understanding these patterns is crucial for designing effective robotic systems.","source":"@site/docs/module-1/topics-services.md","sourceDirName":"module-1","slug":"/module-1/topics-services","permalink":"/physical-ai-humanoid-robotics/docs/module-1/topics-services","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/physical-ai-humanoid-robotics/edit/main/docusaurus/docs/module-1/topics-services.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Topics and Services"},"sidebar":"tutorialSidebar","previous":{"title":"ROS Nodes","permalink":"/physical-ai-humanoid-robotics/docs/module-1/ros-nodes"},"next":{"title":"rclpy Bridge","permalink":"/physical-ai-humanoid-robotics/docs/module-1/rclpy-bridge"}}');var o=s(4848),r=s(8453);const t={sidebar_position:3,title:"Topics and Services"},c="Topics and Services",a={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Topics: Publisher-Subscriber Pattern",id:"topics-publisher-subscriber-pattern",level:2},{value:"Example: Sensor Data Topic",id:"example-sensor-data-topic",level:3},{value:"Subscribing to Topics",id:"subscribing-to-topics",level:3},{value:"Services: Request-Response Pattern",id:"services-request-response-pattern",level:2},{value:"Example: Robot Pose Service",id:"example-robot-pose-service",level:3},{value:"When to Use Topics vs Services",id:"when-to-use-topics-vs-services",level:2},{value:"Use Topics when:",id:"use-topics-when",level:3},{value:"Use Services when:",id:"use-services-when",level:3},{value:"Humanoid Robotics Communication Patterns",id:"humanoid-robotics-communication-patterns",level:2},{value:"Exercise",id:"exercise",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"topics-and-services",children:"Topics and Services"})}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 provides two primary communication patterns: topics (for asynchronous, broadcast communication) and services (for synchronous, request-response communication). Understanding these patterns is crucial for designing effective robotic systems."}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(n.p,{children:"After completing this lesson, you will be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Understand the differences between topics and services"}),"\n",(0,o.jsx)(n.li,{children:"Implement publishers and subscribers for topics"}),"\n",(0,o.jsx)(n.li,{children:"Create and use services for request-response communication"}),"\n",(0,o.jsx)(n.li,{children:"Apply appropriate communication patterns to humanoid robotics scenarios"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"topics-publisher-subscriber-pattern",children:"Topics: Publisher-Subscriber Pattern"}),"\n",(0,o.jsx)(n.p,{children:"Topics enable asynchronous, one-to-many communication between nodes. Publishers send messages to a topic, and any number of subscribers can receive those messages. This pattern is ideal for continuous data streams like sensor readings or robot state information."}),"\n",(0,o.jsx)(n.h3,{id:"example-sensor-data-topic",children:"Example: Sensor Data Topic"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\n\nclass HumanoidSensorPublisher(Node):\n    def __init__(self):\n        super().__init__('humanoid_sensor_publisher')\n        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)\n        timer_period = 0.1  # seconds\n        self.timer = self.create_timer(timer_period, self.publish_sensor_data)\n\n    def publish_sensor_data(self):\n        msg = JointState()\n        msg.name = ['hip_joint', 'knee_joint', 'ankle_joint']\n        msg.position = [0.1, 0.2, 0.3]  # Example positions in radians\n        msg.velocity = [0.0, 0.0, 0.0]\n        msg.effort = [0.0, 0.0, 0.0]\n\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Published joint states: {msg.position}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    sensor_publisher = HumanoidSensorPublisher()\n\n    try:\n        rclpy.spin(sensor_publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        sensor_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"subscribing-to-topics",children:"Subscribing to Topics"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\n\nclass JointStateSubscriber(Node):\n    def __init__(self):\n        super().__init__('joint_state_subscriber')\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.listener_callback,\n            10)\n        self.subscription  # Prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'Received joint positions: {msg.position}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    joint_subscriber = JointStateSubscriber()\n\n    try:\n        rclpy.spin(joint_subscriber)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        joint_subscriber.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"services-request-response-pattern",children:"Services: Request-Response Pattern"}),"\n",(0,o.jsx)(n.p,{children:"Services provide synchronous, one-to-one communication where a client sends a request and waits for a response. This pattern is ideal for actions that require confirmation or computation, like requesting a specific robot pose or executing a complex behavior."}),"\n",(0,o.jsx)(n.h3,{id:"example-robot-pose-service",children:"Example: Robot Pose Service"}),"\n",(0,o.jsxs)(n.p,{children:["First, define the service interface in a ",(0,o.jsx)(n.code,{children:".srv"})," file (e.g., ",(0,o.jsx)(n.code,{children:"SetPose.srv"}),"):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"# Request\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 qx\nfloat64 qy\nfloat64 qz\nfloat64 qw\n---\n# Response\nbool success\nstring message\n"})}),"\n",(0,o.jsx)(n.p,{children:"Then implement the service server:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import SetBool  # Using a standard service for simplicity\n\nclass HumanoidPoseService(Node):\n    def __init__(self):\n        super().__init__('humanoid_pose_service')\n        self.srv = self.create_service(\n            SetBool,\n            'set_humanoid_pose',\n            self.set_pose_callback)\n\n    def set_pose_callback(self, request, response):\n        # In a real implementation, this would set the humanoid's pose\n        self.get_logger().info(f'Setting pose to: {request.data}')\n\n        response.success = True\n        response.message = 'Pose set successfully'\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    pose_service = HumanoidPoseService()\n\n    try:\n        rclpy.spin(pose_service)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        pose_service.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.p,{children:"And the service client:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import SetBool\n\nclass PoseClientAsync(Node):\n    def __init__(self):\n        super().__init__('pose_client')\n        self.cli = self.create_client(SetBool, 'set_humanoid_pose')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = SetBool.Request()\n\n    def send_request(self, pose_data):\n        self.req.data = pose_data\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    pose_client = PoseClientAsync()\n\n    response = pose_client.send_request(True)\n    pose_client.get_logger().info(f'Response: {response.success}, {response.message}')\n\n    pose_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-topics-vs-services",children:"When to Use Topics vs Services"}),"\n",(0,o.jsx)(n.h3,{id:"use-topics-when",children:"Use Topics when:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Broadcasting information to multiple subscribers"}),"\n",(0,o.jsx)(n.li,{children:"Continuous data streams (sensors, robot state)"}),"\n",(0,o.jsx)(n.li,{children:"Real-time requirements (no blocking)"}),"\n",(0,o.jsx)(n.li,{children:"Data doesn't require acknowledgment"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"use-services-when",children:"Use Services when:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Requesting specific actions or computations"}),"\n",(0,o.jsx)(n.li,{children:"Need confirmation of completion"}),"\n",(0,o.jsx)(n.li,{children:"One-to-one communication is sufficient"}),"\n",(0,o.jsx)(n.li,{children:"Request-response pattern fits the use case"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"humanoid-robotics-communication-patterns",children:"Humanoid Robotics Communication Patterns"}),"\n",(0,o.jsx)(n.p,{children:"In humanoid robotics, common communication patterns include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Topics"}),": Joint states, sensor data, robot pose, camera feeds"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Services"}),": Set robot pose, execute behavior, calibration, emergency stop"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Actions"}),": Complex tasks that take time (walking, grasping) with feedback"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"exercise",children:"Exercise"}),"\n",(0,o.jsxs)(n.p,{children:["Create a ROS 2 node that publishes IMU sensor data to a topic called ",(0,o.jsx)(n.code,{children:"imu_data"})," and another node that subscribes to this topic to monitor the humanoid's orientation."]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"Topics and services provide the fundamental communication mechanisms in ROS 2. Understanding when and how to use each pattern is essential for creating robust and efficient humanoid robotics applications. Topics are ideal for continuous data streams, while services are perfect for request-response interactions."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>t,x:()=>c});var i=s(6540);const o={},r=i.createContext(o);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);