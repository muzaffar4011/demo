"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[3512],{6923(e,n,r){r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1/rclpy-bridge","title":"rclpy Bridge","description":"The rclpy package is the Python client library for ROS 2. It provides the Python API for developing ROS 2 packages and enables Python developers to create ROS 2 nodes, publishers, subscribers, services, and more.","source":"@site/docs/module-1/rclpy-bridge.md","sourceDirName":"module-1","slug":"/module-1/rclpy-bridge","permalink":"/physical-ai-humanoid-robotics/docs/module-1/rclpy-bridge","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/physical-ai-humanoid-robotics/edit/main/docusaurus/docs/module-1/rclpy-bridge.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"rclpy Bridge"},"sidebar":"tutorialSidebar","previous":{"title":"Topics and Services","permalink":"/physical-ai-humanoid-robotics/docs/module-1/topics-services"},"next":{"title":"URDF for Humanoids","permalink":"/physical-ai-humanoid-robotics/docs/module-1/urdf-humanoids"}}');var i=r(4848),t=r(8453);const l={sidebar_position:4,title:"rclpy Bridge"},o="rclpy Bridge",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to rclpy",id:"introduction-to-rclpy",level:2},{value:"Key Components of rclpy",id:"key-components-of-rclpy",level:3},{value:"Basic Node Structure with rclpy",id:"basic-node-structure-with-rclpy",level:2},{value:"Publishers and Subscribers with rclpy",id:"publishers-and-subscribers-with-rclpy",level:2},{value:"Publisher Example",id:"publisher-example",level:3},{value:"Subscriber Example",id:"subscriber-example",level:3},{value:"Services and Clients with rclpy",id:"services-and-clients-with-rclpy",level:2},{value:"Service Server Example",id:"service-server-example",level:3},{value:"Service Client Example",id:"service-client-example",level:3},{value:"Advanced rclpy Features for Humanoid Robotics",id:"advanced-rclpy-features-for-humanoid-robotics",level:2},{value:"Working with Custom Message Types",id:"working-with-custom-message-types",level:3},{value:"Parameter Handling",id:"parameter-handling",level:3},{value:"Best Practices for rclpy in Humanoid Robotics",id:"best-practices-for-rclpy-in-humanoid-robotics",level:2},{value:"Exercise",id:"exercise",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rclpy-bridge",children:"rclpy Bridge"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"rclpy"})," package is the Python client library for ROS 2. It provides the Python API for developing ROS 2 packages and enables Python developers to create ROS 2 nodes, publishers, subscribers, services, and more."]}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After completing this lesson, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand the role of rclpy in ROS 2 Python development"}),"\n",(0,i.jsx)(n.li,{children:"Create ROS 2 nodes using rclpy"}),"\n",(0,i.jsx)(n.li,{children:"Implement publishers, subscribers, services, and clients with rclpy"}),"\n",(0,i.jsx)(n.li,{children:"Bridge Python agents with ROS 2 for humanoid robotics applications"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-rclpy",children:"Introduction to rclpy"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rclpy"})," is the official Python client library for ROS 2. It provides Python bindings for the ROS 2 middleware (RCL - ROS Client Library), allowing Python developers to interact with the ROS 2 ecosystem. For humanoid robotics applications, rclpy enables the integration of complex Python-based AI algorithms with the ROS 2 communication framework."]}),"\n",(0,i.jsx)(n.h3,{id:"key-components-of-rclpy",children:"Key Components of rclpy"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Node"}),": The basic execution unit that can communicate with other nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Publisher"}),": Sends messages to topics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subscriber"}),": Receives messages from topics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service Server"}),": Provides services that other nodes can call"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service Client"}),": Calls services provided by other nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timer"}),": Executes callbacks at regular intervals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter"}),": Handles node configuration parameters"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-node-structure-with-rclpy",children:"Basic Node Structure with rclpy"}),"\n",(0,i.jsx)(n.p,{children:"Here's the standard structure for a ROS 2 node using rclpy:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\n\nclass MyRobotNode(Node):\n    def __init__(self):\n        super().__init__('my_robot_node')\n        # Initialize publishers, subscribers, services, etc. here\n\n    def destroy_node(self):\n        # Cleanup operations before node destruction\n        super().destroy_node()\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    my_robot_node = MyRobotNode()\n\n    try:\n        rclpy.spin(my_robot_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        my_robot_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"publishers-and-subscribers-with-rclpy",children:"Publishers and Subscribers with rclpy"}),"\n",(0,i.jsx)(n.h3,{id:"publisher-example",children:"Publisher Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass CommandPublisher(Node):\n    def __init__(self):\n        super().__init__('command_publisher')\n        self.publisher_ = self.create_publisher(String, 'robot_commands', 10)\n        self.timer = self.create_timer(0.5, self.timer_callback)\n        self.counter = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Command {self.counter}: Move forward'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: {msg.data}')\n        self.counter += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    command_publisher = CommandPublisher()\n\n    try:\n        rclpy.spin(command_publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        command_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"subscriber-example",children:"Subscriber Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass CommandSubscriber(Node):\n    def __init__(self):\n        super().__init__('command_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'robot_commands',\n            self.listener_callback,\n            10)\n        self.subscription  # Prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'Received command: {msg.data}')\n        # Process the command here\n\ndef main(args=None):\n    rclpy.init(args=args)\n    command_subscriber = CommandSubscriber()\n\n    try:\n        rclpy.spin(command_subscriber)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        command_subscriber.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"services-and-clients-with-rclpy",children:"Services and Clients with rclpy"}),"\n",(0,i.jsx)(n.h3,{id:"service-server-example",children:"Service Server Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Returning {response.sum}')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n\n    try:\n        rclpy.spin(minimal_service)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        minimal_service.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"service-client-example",children:"Service Client Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalClientAsync(Node):\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        return self.future\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_client = MinimalClientAsync()\n\n    future = minimal_client.send_request(1, 2)\n\n    try:\n        rclpy.spin_until_future_complete(minimal_client, future)\n        response = future.result()\n        minimal_client.get_logger().info(f'Result: {response.sum}')\n    except KeyboardInterrupt:\n        pass\n    finally:\n        minimal_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-rclpy-features-for-humanoid-robotics",children:"Advanced rclpy Features for Humanoid Robotics"}),"\n",(0,i.jsx)(n.h3,{id:"working-with-custom-message-types",children:"Working with Custom Message Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom builtin_interfaces.msg import Time\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.msg import JointTrajectoryControllerState\n\nclass HumanoidStateNode(Node):\n    def __init__(self):\n        super().__init__('humanoid_state_node')\n\n        # Publisher for humanoid state\n        self.state_publisher = self.create_publisher(\n            JointTrajectoryControllerState,\n            'humanoid_controller/state',\n            10\n        )\n\n        # Subscriber for joint commands\n        self.joint_subscriber = self.create_subscription(\n            JointState,\n            'joint_commands',\n            self.joint_command_callback,\n            10\n        )\n\n        self.timer = self.create_timer(0.02, self.publish_state)  # 50Hz\n\n    def joint_command_callback(self, msg):\n        # Process joint commands\n        self.get_logger().info(f'Received {len(msg.name)} joint commands')\n\n    def publish_state(self):\n        # Publish current humanoid state\n        msg = JointTrajectoryControllerState()\n        # Fill in the message with current state\n        self.state_publisher.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidStateNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameter-handling",children:"Parameter Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rcl_interfaces.msg import ParameterType\n\nclass ParameterNode(Node):\n    def __init__(self):\n        super().__init__('parameter_node')\n\n        # Declare parameters with default values\n        self.declare_parameter('step_height', 0.1)\n        self.declare_parameter('walking_speed', 0.5)\n        self.declare_parameter('max_torque', 100.0)\n\n        # Get parameter values\n        self.step_height = self.get_parameter('step_height').value\n        self.walking_speed = self.get_parameter('walking_speed').value\n        self.max_torque = self.get_parameter('max_torque').value\n\n        # Set up parameter callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n    def parameter_callback(self, params):\n        for param in params:\n            if param.name == 'step_height' and param.type == ParameterType.PARAMETER_DOUBLE:\n                self.step_height = param.value\n                self.get_logger().info(f'Step height updated to: {self.step_height}')\n        return SetParametersResult(successful=True)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ParameterNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-for-rclpy-in-humanoid-robotics",children:"Best Practices for rclpy in Humanoid Robotics"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Always implement proper error handling in your callbacks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Clean up resources in the destroy_node method"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Threading"}),": Be aware of threading implications when using rclpy"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Optimize message publishing rates based on real-time requirements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logging"}),": Use appropriate log levels (info, warn, error, debug)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"exercise",children:"Exercise"}),"\n",(0,i.jsx)(n.p,{children:"Create a Python node that bridges a simple AI decision-making algorithm with ROS 2. The node should:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Subscribe to sensor data topics"}),"\n",(0,i.jsx)(n.li,{children:"Make decisions based on the sensor input"}),"\n",(0,i.jsx)(n.li,{children:"Publish commands to actuator topics"}),"\n",(0,i.jsx)(n.li,{children:"Use parameters to configure the AI behavior"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"The rclpy library provides Python developers with powerful tools to create ROS 2 nodes for humanoid robotics applications. By understanding its core components and best practices, you can effectively bridge Python-based AI algorithms with the ROS 2 communication framework, enabling sophisticated robotic behaviors."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>l,x:()=>o});var s=r(6540);const i={},t=s.createContext(i);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);